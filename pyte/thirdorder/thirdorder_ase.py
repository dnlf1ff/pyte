#!/usr/bin/env python
# -*- coding: utf-8 -*-
#  thirdorder, help compute anharmonic IFCs from minimal sets of displacements
#  Copyright (C) 2012-2018 Wu Li <wu.li.phys2011@gmail.com>
#  Copyright (C) 2012-2018 Jesús Carrete Montaña <jcarrete@gmail.com>
#  Copyright (C) 2012-2018 Natalio Mingo Bisquert <natalio.mingo@cea.fr>
#  Copyright (C) 2014-2018 Antti J. Karttunen <antti.j.karttunen@iki.fi>
#  Copyright (C) 2016-2018 Genadi Naydenov <gan503@york.ac.uk>
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import print_function
try:
    xrange
except NameError:
    xrange = range


from pyte.util.calc import SevenNetBatchCalculator, single_point_calculate_list
import pyte.thirdorder.thirdorder_core as thirdorder_core
from pyte.thirdorder.thirdorder_common import *
from ase import Atoms
from ase.io import read


def from_atoms(atoms):
    nruter = dict()
    nruter['lattvec'] = atoms.get_cell().array.T * 0.1  # in nm
    elem_type, elem_num = [], []
    elems = atoms.get_chemical_symbols()
    for e in elems:
        if e not in elem_type:
            elem_type.append(e)
            elem_num.append(0)
        elem_num[elem_type.index(e)] += 1
    nruter['elements'] = elem_type
    nruter['numbers'] = np.array(elem_num, dtype=np.intc)
    nruter['positions'] = atoms.get_scaled_positions().T
    nruter['types'] = []
    for i in xrange(len(nruter["numbers"])):
        nruter["types"] += [i] * nruter["numbers"][i]

    return nruter


def to_atoms(poscar):
    formula = ''
    for elem, num in zip(poscar['elements'], poscar['numbers']):
        formula += f'{elem}{num}'
    cell = poscar['lattvec'].T * 10  # back to Angstrom
    atoms = Atoms(formula, cell=cell, pbc=True)
    atoms.set_scaled_positions(poscar['positions'].T)

    return atoms


def normalize_SPOSCAR(sposcar):
    """
    Rearrange sposcar, as generated by gen_SPOSCAR, so that it is in
    valid VASP order, and return the result.
    """
    nruter = copy.deepcopy(sposcar)
    # Order used internally (from most to least significant):
    # k,j,i,iat For VASP, iat must be the most significant index,
    # i.e., atoms of the same element must go together.
    indices = np.array(xrange(nruter["positions"].shape[1])).reshape(
        (sposcar["nc"], sposcar["nb"], sposcar["na"], -1))
    indices = np.rollaxis(indices, 3, 0).flatten().tolist()
    nruter["positions"] = nruter["positions"][:, indices]
    nruter["types"].sort()
    return nruter


def read_forces(atoms):
    forces = atoms.get_forces()
    forces = np.array(forces, dtype=np.double)
    return forces


def build_unpermutation(sposcar):
    """
    Return a list of integers mapping the atoms in the normalized
    version of sposcar to their original indices.
    """
    indices = np.array(xrange(sposcar["positions"].shape[1])).reshape(
        (sposcar["nc"], sposcar["nb"], sposcar["na"], -1))
    indices = np.rollaxis(indices, 3, 0).flatten()
    return indices.argsort().tolist()


def thirdorder_main(na, nb, nc, cut, relaxed_atoms, calc, fname):
    if min(na, nb, nc) < 1:
        raise ValueError("Error: na, nb and nc must be positive integers")

    if cut < 0:
        nneigh = -int(cut)
    elif cut > 0:
        nneigh = None
        frange = float(cut)
    else:
        raise ValueError('cut should not be zero')

    poscar = from_atoms(relaxed_atoms)
    natoms = len(poscar["types"])
    symops = thirdorder_core.SymmetryOperations(
        poscar["lattvec"], poscar["types"], poscar["positions"].T, SYMPREC)
    sposcar = gen_SPOSCAR(poscar, na, nb, nc)
    ntot = natoms * na * nb * nc
    dmin, nequi, shifts = calc_dists(sposcar)
    if nneigh != None:
        frange = calc_frange(poscar, sposcar, nneigh, dmin)
    wedge = thirdorder_core.Wedge(
        poscar,
        sposcar,
        symops,
        dmin,
        nequi,
        shifts,
        frange,
    )
    list4 = wedge.build_list4()
    nirred = len(list4)
    nruns = 4 * nirred

    width = len(str(4 * (len(list4) + 1)))
    atoms_list = list(range(nirred*3+len(list4)))
    for i, e in enumerate(list4):
        for n in xrange(4):
            isign = (-1)**(n // 2)
            jsign = -(-1)**(n % 2)
            number = nirred * n + i
            dsposcar = normalize_SPOSCAR(
                move_two_atoms(sposcar, e[1], e[3], isign * H, e[0], e[2],
                               jsign * H))
            atoms_list[number] = to_atoms(dsposcar)

    desc = 'fc3 calculate shengBTE'
    if isinstance(calc, SevenNetBatchCalculator):
        atoms_list = calc.batch_calculate(atoms_list, desc=desc)
    else:
        atoms_list = single_point_calculate_list(atoms_list, calc, desc=desc)
    p = build_unpermutation(sposcar)
    forces = []
    for atoms in atoms_list:
        forces.append(read_forces(atoms)[p, :])
        res = forces[-1].mean(axis=0)
    phipart = np.zeros((3, nirred, ntot))
    for i, e in enumerate(list4):
        for n in xrange(4):
            isign = (-1)**(n // 2)
            jsign = -(-1)**(n % 2)
            number = nirred * n + i
            phipart[:, i, :] -= isign * jsign * forces[number].T
    phipart /= (400. * H * H)
    phifull = thirdorder_core.reconstruct_ifcs(phipart, wedge, list4,
                                               poscar, sposcar)
    write_ifcs(
        phifull,
        poscar,
        sposcar,
        dmin,
        nequi,
        shifts,
        frange,
        fname,
    )

    return len(atoms_list)
